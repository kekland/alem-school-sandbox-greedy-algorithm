(()=>{var t={196:(t,e,s)=>{var o=s(147),n="";t.exports=function(){0===n.length&&(n=function(t){var e=Buffer.alloc(256),s=Buffer.alloc(256),n=0,a=0,i=!1,r=process.stdin.fd,l=!1;try{r=o.openSync("/dev/stdin","rs+"),l=!0}catch(t){}for(;;){try{a=o.readSync(r,e,0,256,null);var c=Buffer.alloc(n+a);s.copy(c,0,0,n),e.copy(c,n,0,a),s=c,n+=a;for(var u=0;u<a;u++)if(e[u]===t){i=!0;break}if(i)break}catch(t){if("EOF"===t.code)break;if("EAGAIN"===t.code)continue;throw t}if(0===a)break}return l&&o.closeSync(r),s}("\n".charCodeAt(0)).toString("utf-8"));var t=n.search("\n")+1,e=n.slice(0,t);return n=n.slice(t),e.trim()}},601:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Constants=void 0,e.Constants={coinPayoff:1,daggerPayoff:4,criticalDaggerPayoff:1e7,pathSafetyRelativeDangerScale:.1,pathSafetyRelativeDangerThreshold:3.5,pathSafetyDangerousMultiplier:.1,safetyPayoff:1e4,killPayoff:4,bonusPayoff:4,daggerLife:15,bonusLife:15,daggerEquippedLife:15,bonusEquippedLife:30,safetyThreshold:5,safetyIterationDepth:5,defaultVisibilityRadius:5}},836:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.actionListToString=e.actionToVector2=e.inverseAction=e.Action=void 0;const o=s(561);var n;!function(t){t.left="left",t.right="right",t.up="up",t.down="down",t.stay="stay"}(n=e.Action||(e.Action={})),e.inverseAction=t=>{switch(t){case n.left:return n.right;case n.right:return n.left;case n.up:return n.down;case n.down:return n.up;default:return n.stay}},e.actionToVector2=t=>{switch(t){case n.left:return new o.Vector2(-1,0);case n.right:return new o.Vector2(1,0);case n.up:return new o.Vector2(0,-1);case n.down:return new o.Vector2(0,1);default:return new o.Vector2(0,0)}},e.actionListToString=t=>t.join(", ")},247:(t,e)=>{"use strict";function s(t){return void 0!==t.id&&void 0!==t.position}Object.defineProperty(e,"__esModule",{value:!0}),e.isMonster=e.isPlayer=e.isEntity=void 0,e.isEntity=s,e.isPlayer=t=>s(t)&&"player"===t.type,e.isMonster=t=>s(t)&&"monster"===t.type},916:(t,e)=>{"use strict";var s;Object.defineProperty(e,"__esModule",{value:!0}),e.stringToBlock=e.getBlockName=e.Block=void 0,function(t){t.empty=".",t.wall="!",t.coin="#",t.dagger="d",t.bonus="b"}(s=e.Block||(e.Block={})),e.getBlockName=t=>{switch(t){case s.empty:return"empty";case s.wall:return"wall";case s.coin:return"coin";case s.dagger:return"dagger";case s.bonus:return"bonus"}},e.stringToBlock=t=>{switch(t){case".":return s.empty;default:return s.wall;case"#":return s.coin;case"d":return s.dagger;case"b":return s.bonus}}},532:function(t,e,s){"use strict";var o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.getState=void 0;const n=s(561),a=s(916),i=o(s(196)),r=s(601),l=s(73),c=s(656);e.getState=({history:t})=>{var e,s;const o=t.length>0?t[t.length-1]:null;let u,f,p,d,y=(0,i.default)();[u,f,p,d]=y.split(" ").map((t=>parseInt(t)));const g=[];for(let t=0;t<f;t++){const t=(0,i.default)().split("").map((t=>(0,a.stringToBlock)(t)));g.push(t)}const h=parseInt((0,i.default)()),b={},v={};for(let t=0;t<h;t++){const a=(0,i.default)().split(" "),u=a[0],f=parseInt(a[1]),p=parseInt(a[2]),y=parseInt(a[3]),h=parseInt(a[4]),m=parseInt(a[5]),k=new n.Vector2(p,y);if("m"===u){let e=t;if(o){let s=Object.values(o.monsters).filter((t=>t.position.equals(k)));if(1===s.length)e=s[0].id;else{let s=Object.values(o.monsters).filter((t=>(0,l.isTraversableInOneMove)({start:t.position,end:k})));1!==s.length&&(console.error(`${t} index failure monsters len > 1:`,k,s),s=s.filter((t=>(0,c.isInMonsterRealm)({position:k,realms:o.map.monsterRealms,blocks:g}).includes(t.id)))),1===s.length?e=s[0].id:console.error(`${t} critical failure len > 1:`,k,s)}}b[e]={id:e,type:"monster",position:k}}else if("p"===u){const t={type:"player",id:f,position:k,dagger:null,bonus:null},n=(t,e)=>e?{firstTick:e.firstTick,ticksLeft:e.ticksLeft-1}:{firstTick:d,ticksLeft:t};1===h&&(t.dagger=n(r.Constants.daggerEquippedLife,null===(e=null==o?void 0:o.players[f])||void 0===e?void 0:e.dagger)),1===m&&(t.bonus=n(r.Constants.bonusEquippedLife,null===(s=null==o?void 0:o.players[f])||void 0===s?void 0:s.bonus)),v[f]=t}}const m=[a.Block.dagger,a.Block.bonus],k=[];for(let t=0;t<g.length;t++)for(let e=0;e<g[t].length;e++){const s=new n.Vector2(e,t),a=o?o.map.blockStates.find((t=>t.position.equals(s))):null,i=m.includes(g[t][e]);a&&i?k.push(a):!a&&i&&k.push({position:s,firstTick:d})}let x;if(o)x=Object.fromEntries(Object.entries(o.map.monsterRealms).filter((t=>Object.keys(b).includes(t[0]))));else{x={};for(const t of Object.values(b))x[t.id]=t.position}return{tick:d,playerId:p,monsters:b,players:v,map:{width:u,height:f,blocks:g,blockStates:k,monsterRealms:x}}}},84:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.resolveBonusIntent=void 0;const o=s(601),n=s(656),a=s(73);e.resolveBonusIntent=({state:t,player:e,paths:s,safetyMatrix:i})=>{const r=[];for(const l of s){const s=t.map.blockStates.find((t=>t.position.equals(l.end))),c=o.Constants.bonusLife-(t.tick-s.firstTick);if(l.actions.length>=c)continue;const u=(0,n.isPathSafeWithDagger)({daggerState:e.dagger,path:l})?1:(0,a.getPathSafety)({path:l,safetyMatrix:i});r.push({actions:l.actions,certainty:u,duration:l.actions.length,payoff:o.Constants.bonusPayoff,target:l.end,validateSafety:!0})}return r}},585:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.resolveCoinIntent=void 0;const o=s(601),n=s(656),a=s(73);e.resolveCoinIntent=({state:t,player:e,paths:s,safetyMatrix:i})=>{const r=[];for(const t of s){const s=(0,n.isPathSafeWithDagger)({daggerState:e.dagger,path:t})?1:(0,a.getPathSafety)({path:t,safetyMatrix:i});r.push({actions:t.actions,certainty:s,duration:t.actions.length,payoff:o.Constants.coinPayoff*(null!=e.bonus?2:1),target:t.end,validateSafety:!0})}return r}},686:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.resolveDaggerIntent=void 0;const o=s(601),n=s(73);e.resolveDaggerIntent=({state:t,player:e,paths:s,safetyMatrix:a})=>{const i=a[e.position.y][e.position.x],r=[];if(0===Object.keys(t.monsters).length)return r;for(const e of s){const s=t.map.blockStates.find((t=>t.position.equals(e.end))),l=o.Constants.daggerLife-(t.tick-s.firstTick);if(e.actions.length>=l)continue;let c=!0;(0,n.simulatePath)(e,((t,e)=>{a[e.y][e.x]<=2*(t+1)&&(c=!1)}));const u=(0,n.getPathSafety)({path:e,safetyMatrix:a});r.push({actions:e.actions,certainty:c?1:u,duration:e.actions.length,payoff:i<=o.Constants.safetyThreshold&&c?o.Constants.criticalDaggerPayoff:o.Constants.daggerPayoff,target:e.end,validateSafety:!0})}return r}},458:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0})},958:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.resolveKillIntent=void 0;const o=s(601);e.resolveKillIntent=({state:t,paths:e,player:s,safetyMatrix:n})=>{if(null==s.dagger)return[];const a=[];for(const t of e){const e=t.actions.length;s.dagger.ticksLeft<e/1.5||e<=4&&a.push({certainty:1,actions:t.actions,duration:t.actions.length,payoff:o.Constants.killPayoff,target:t.end,validateSafety:!1})}return a}},989:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.resolveSafetyIntent=e.escapePathsFromPosition=e.isDeath=e.isInDanger=void 0;const o=s(601),n=s(656),a=s(857),i=s(73),r=s(974);e.isInDanger=({position:t,blocks:e,player:s,pursuers:a,safetyMatrix:i,visibilityMatrix:r,monsterRealms:l})=>{const c=i[t.y][t.x],u=(0,n.isInMonsterRealm)({blocks:e,position:t,realms:l});return!(null!=s.dagger&&s.dagger.ticksLeft>6||c>o.Constants.safetyThreshold-2&&0===a.length||c>o.Constants.safetyThreshold||0===u.length&&c>3)},e.isDeath=({position:t,player:e,safetyMatrix:s,blocks:o,monsterRealms:a})=>{const i=s[t.y][t.x];let r=!1;return(0,n.iterateOnGameMap)({start:t,blocks:o,maxDepth:i,callback:(t,e)=>s[t.y][t.x]<i||(r=!0,!1)}),!r},e.escapePathsFromPosition=({position:t,player:e,state:s,dangers:l,monsterRealms:c,safetyMatrix:u,visibilityMatrix:f,depth:p})=>{const d={};for(const t of l)d[l.indexOf(t)]=t;const y={},g={};return(0,a.iterateOnGameMapBranched)({start:t,blocks:s.map.blocks,maxDepth:null!=p?p:o.Constants.safetyIterationDepth,callback:(e,o)=>{var a,l;const u=o.length;if(y[""]=Object.assign({},d),0===u)return!1;const f=o.slice(0,u-1),p=(0,n.actionListToString)(o),h=(0,n.actionListToString)(f),b=(e.sub((0,n.actionToVector2)(o[o.length-1])),null!=y[h]?Object.assign({},y[h]):Object.assign({},d));for(const t in b)if(b[t].equals(e))return!0;const v=[],m=(0,n.isInMonsterRealm)({blocks:s.map.blocks,position:t,realms:c});for(const t in b){const o=t,a=b[o];((0,r.manhattanDistance)(a,e)<=5||m.includes(o))&&v.push(o);const i=(0,n.calcuateSafety)({blocks:s.map.blocks,position:e,dangers:[a]});if(0===u&&0===i)return!0}let k=0;for(const t of v){const o=b[t],a=[n.Action.down,n.Action.right,n.Action.left,n.Action.up];let i,r=1/0;for(const t of a){const a=o.add((0,n.actionToVector2)(t));if((x=a).x<0||x.y<0||x.x>=s.map.width||x.y>=s.map.height||s.map.blocks[x.y][x.x]===n.Block.wall)continue;let l=(0,n.calcuateSafety)({blocks:s.map.blocks,dangers:[a],position:e});l<r?(r=l,i=t):l==r&&(k+=1)}const l=o.add((0,n.actionToVector2)(i));b[t]=l}var x;y[p]=Object.assign({},b);const M=(0,n.calcuateSafety)({blocks:s.map.blocks,position:e,dangers:Object.values(b)});if(M<=1)return!0;let P=0;const O={actions:o,start:t,end:e,type:"safety"};(0,i.simulatePath)(O,((t,e)=>{s.map.blocks[e.y][e.x]===n.Block.coin&&P++,s.map.blocks[e.y][e.x]===n.Block.dagger&&(P+=1e3)}));const S=[];for(let t=0;t<=o.length;t++){const e=o.slice(0,t),s=Object.values(y[(0,n.actionListToString)(e)]);S.push(s)}return g[p]={path:O,safety:M,coinsCollected:P,probability:(null!==(l=null===(a=g[h])||void 0===a?void 0:a.probability)&&void 0!==l?l:1)*(1/k)*1,historicalDangers:S},!1}}),Object.values(g).filter((t=>t.path.actions.length>o.Constants.safetyIterationDepth/2))},e.resolveSafetyIntent=({state:t,paths:s,player:n,monsterRealms:a,safetyMatrix:i,visibilityMatrix:r})=>{const l=(0,e.escapePathsFromPosition)({dangers:s.map((t=>t.end)),player:n,position:n.position,safetyMatrix:i,state:t,monsterRealms:a,visibilityMatrix:r});return null==l?[]:l.map((t=>{const e=i[t.path.end.y][t.path.end.x];return{payoff:o.Constants.safetyPayoff+2*e+t.coinsCollected,certainty:1/t.path.actions.length,duration:1,actions:t.path.actions,target:t.path.end,validateSafety:!1,description:t.historicalDangers}}))}},656:function(t,e,s){"use strict";var o=this&&this.__createBinding||(Object.create?function(t,e,s,o){void 0===o&&(o=s),Object.defineProperty(t,o,{enumerable:!0,get:function(){return e[s]}})}:function(t,e,s,o){void 0===o&&(o=s),t[o]=e[s]}),n=this&&this.__exportStar||function(t,e){for(var s in t)"default"===s||Object.prototype.hasOwnProperty.call(e,s)||o(e,t,s)};Object.defineProperty(e,"__esModule",{value:!0}),n(s(836),e),n(s(247),e),n(s(916),e),n(s(532),e),n(s(458),e),n(s(388),e),n(s(816),e),n(s(154),e),n(s(410),e),n(s(561),e),n(s(165),e)},388:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateOnGameMap=e._traversalActionsHorizontalPriority=e._traversalActionsVerticalPriority=void 0;const o=s(836),n=s(916);e._traversalActionsVerticalPriority=[o.Action.up,o.Action.down,o.Action.left,o.Action.right],e._traversalActionsHorizontalPriority=[o.Action.left,o.Action.right,o.Action.up,o.Action.down],e.iterateOnGameMap=({start:t,blocks:s,maxDepth:a,callback:i,verticalPriority:r})=>{const l=null!=a?a:1e4,c=[];for(let t=0;t<s.length;t++){c.push([]);for(let e=0;e<s[t].length;e++)c[t].push(!1)}const u=[{position:t,actions:[],depth:0}],f=null==r||r?e._traversalActionsVerticalPriority:e._traversalActionsHorizontalPriority;for(;u.length>0;){const t=u.shift();if(!t)break;const{position:e,actions:a,depth:r}=t;if(!(r>l)&&!i(e,a))for(const t of f){const i=e.add((0,o.actionToVector2)(t));(p=i).x>=0&&p.y>=0&&p.x<s[0].length&&p.y<s.length&&!(t=>s[t.y][t.x]===n.Block.wall)(p)&&!c[p.y][p.x]&&(u.push({position:i,actions:[...a,t],depth:r+1}),c[i.y][i.x]=!0)}}var p}},857:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateOnGameMapBranched=e._traversalActions=void 0;const o=s(656);e._traversalActions=[o.Action.up,o.Action.down,o.Action.left,o.Action.right],e.iterateOnGameMapBranched=({start:t,blocks:s,maxDepth:n,callback:a})=>{const i=null!=n?n:4,r=t=>t.x>=0&&t.y>=0&&t.x<s[0].length&&t.y<s.length&&!(t=>s[t.y][t.x]===o.Block.wall)(t),l=(t,s,n,a,c)=>{for(const u of e._traversalActions.filter((t=>t!==(0,o.inverseAction)(a[a.length-1])))){const e=t.add((0,o.actionToVector2)(u));n<i&&r(e)&&!c(e,[...a,u])&&l(e,s,n+1,[...a,u],c)}};a(t,[]),l(t,s,0,[],a)}},73:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calculateShortestPath=e.isTraversableInOneMove=e.getPathSafety=e.simulatePath=e.isPathEntity=e.isPathBlock=e.pathToString=void 0;const o=s(601),n=s(656);e.pathToString=t=>`${t.type} ${t.start.x} ${t.start.y} ${t.end.x} ${t.end.y} ${t.actions.map(n.actionToVector2).join(" ")}`,e.isPathBlock=t=>"block"===t.type,e.isPathEntity=t=>"entity"===t.type,e.simulatePath=(t,e)=>{let s=t.start,o=0;for(const a of t.actions){if(e(o,s))return;s=s.add((0,n.actionToVector2)(a)),o+=1}},e.getPathSafety=({path:t,safetyMatrix:s})=>{let n=1;return(0,e.simulatePath)(t,((t,e)=>{s[e.y][e.x]-t*o.Constants.pathSafetyRelativeDangerScale<=o.Constants.pathSafetyRelativeDangerThreshold&&(n*=o.Constants.pathSafetyDangerousMultiplier)})),n},e.isTraversableInOneMove=({start:t,end:e})=>{const s=e.sub(t);return Math.abs(s.x)+Math.abs(s.y)===1},e.calculateShortestPath=({start:t,end:e,blocks:s,verticalPriority:o})=>{let a;return(0,n.iterateOnGameMap)({start:t,blocks:s,verticalPriority:o,callback:(s,o)=>(s.equals(e)&&(a={type:"position",start:t,end:e,actions:o}),void 0!==a)}),a}},816:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getDangerousPointsOfInterest=e.getPointsOfInterestWithSafety=e.getPointsOfInterest=void 0;const o=s(656),n=s(388),a=s(154),i=[o.Block.coin,o.Block.dagger,o.Block.bonus];e.getPointsOfInterest=({start:t,blocks:e,entities:s,predicate:o})=>{const a=[],r=[];return(0,n.iterateOnGameMap)({start:t,blocks:e,callback:(n,l)=>{if(o&&o(l.length,n))return!0;const c=e[n.y][n.x],u=s.find((t=>t.position.x===n.x&&t.position.y===n.y));return i.includes(c)&&a.push({type:"block",start:t,end:n,actions:l,target:c}),null!=u&&r.push({type:"player"===u.type?"player":"monster",start:t,end:n,actions:l,target:u.id}),!1}}),{blocks:a,entities:r}},e.getPointsOfInterestWithSafety=({start:t,blocks:s,safetyMatrix:o,visibilityMatrix:n,monsterRealms:i,entities:r})=>{const l=(0,e.getPointsOfInterest)({start:t,blocks:s,entities:r,predicate:(t,e)=>(0,a.isInMonsterRealm)({blocks:s,position:e,realms:i}).length>0||o[e.y][e.x]<=2});return 0!==l.blocks.length?l:(0,e.getPointsOfInterest)({start:t,blocks:s,entities:r,predicate:(t,e)=>!(t<=1)&&o[e.y][e.x]<=1})},e.getDangerousPointsOfInterest=({poi:t,safePoi:e})=>{const s={blocks:[],entities:[]};for(const o of t.blocks)null==e.blocks.find((t=>t.end.equals(o.end)))&&s.blocks.push(o);for(const o of Object.values(t.entities))null==e.entities[o.target]&&(s.entities[o.target]=o);return s}},154:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getPursuers=e.isInMonsterRealm=e.isPathSafeWithDagger=e.calcuateSafety=e.calculateSafetyMatrix=void 0;const o=s(388);e.calculateSafetyMatrix=({blocks:t,dangers:e})=>{const s=[];for(let e=0;e<t.length;e++){s.push([]);for(let o=0;o<t[e].length;o++)s[e].push(Number.MAX_SAFE_INTEGER)}for(const n of e)(0,o.iterateOnGameMap)({start:n,blocks:t,callback:(t,e)=>{const o=e.length;return s[t.y][t.x]=Math.min(s[t.y][t.x],o),!1}});return s},e.calcuateSafety=({position:t,blocks:s,dangers:o})=>(0,e.calculateSafetyMatrix)({blocks:s,dangers:o})[t.y][t.x],e.isPathSafeWithDagger=({daggerState:t,path:e})=>null!=t&&t.ticksLeft>3,e.isInMonsterRealm=({position:t,blocks:s,realms:o})=>{const n=[];for(const a in o)(0,e.calculateSafetyMatrix)({blocks:s,dangers:[o[a]]})[t.y][t.x]<=4&&n.push(a);return n},e.getPursuers=({blocks:t,realms:s,history:o})=>{if(o.length<2)return[];const n=[],a={},{monsters:i}=o[o.length-1];for(const t in i)a[t]=[];for(const t in a)for(const{monsters:e}of o)a[t].push(e[t].position);for(const i in a){const r=i,l=a[i],c=o.length-1,u=o.length-2,f=o[c],p=o[u],d=f.otherPosition,y=Math.min(8,(0,e.calcuateSafety)({position:f.position,blocks:t,dangers:[l[c]]})),g=Math.min(8,(0,e.calcuateSafety)({position:p.position,blocks:t,dangers:[l[u]]}));if(d&&Math.min(8,(0,e.calcuateSafety)({position:d,blocks:t,dangers:[l[c]]}))<y)continue;const h=(0,e.isInMonsterRealm)({position:p.position,blocks:t,realms:s});(y<=5&&y<=g&&h.includes(r)||y<=4&&y<=g&&!h.includes(r))&&n.push(r)}return n}},410:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.tick=e.getSortedIntents=void 0;const o=s(836),n=s(84),a=s(585),i=s(686),r=s(958),l=s(989),c=s(656),u=s(73),f=s(816);e.getSortedIntents=({state:t,stateHistory:e,intentHistory:s})=>{var p,d;const y=t.players[t.playerId],g=Object.values(t.monsters),h=Object.values(t.players),b=g.map((t=>t.id)),v=(h.map((t=>t.id)),h.filter((e=>e.id!==t.playerId))),m=(0,c.calculateSafetyMatrix)({blocks:t.map.blocks,dangers:g.map((t=>t.position))}),k=(0,c.calculateVisibilityMatrix)({blocks:t.map.blocks,positions:g.map((t=>t.position))}),x=t.map.monsterRealms,M={start:y.position,blocks:t.map.blocks,entities:[...g,...v]},P=(0,c.getPursuers)({realms:t.map.monsterRealms,blocks:t.map.blocks,history:e.map((t=>{var e;return{position:t.players[t.playerId].position,otherPosition:null===(e=Object.values(t.players).find((e=>e.id!==t.playerId)))||void 0===e?void 0:e.position,monsters:t.monsters}}))}),O=(0,l.isInDanger)({player:y,pursuers:P,blocks:t.map.blocks,position:y.position,monsterRealms:x,safetyMatrix:m,visibilityMatrix:k});console.error("---State---"),console.error(`Position: ${y.position.toString()}`),console.error(`Danger: ${O}`),console.error(`Safety: ${m[y.position.y][y.position.x]}`),console.error(`Dagger: ${null===(p=y.dagger)||void 0===p?void 0:p.ticksLeft}, Bonus: ${null===(d=y.bonus)||void 0===d?void 0:d.ticksLeft}`),console.error(`Realms: ${(0,c.isInMonsterRealm)({position:y.position,blocks:t.map.blocks,realms:x})}`),console.error(`Pursuers: ${JSON.stringify(P)}`),console.error("-----------");const S=(0,f.getPointsOfInterest)(M),I=(0,f.getPointsOfInterestWithSafety)(Object.assign(Object.assign({},M),{safetyMatrix:m,visibilityMatrix:k,monsterRealms:x})),_=(0,f.getDangerousPointsOfInterest)({poi:S,safePoi:I}),j={state:t,player:y,safetyMatrix:m,visibilityMatrix:k,monsterRealms:x};let D;D=null!=y.dagger?_.blocks.length>0?_:S:I.blocks.length>0?I:S;const A=S.entities.filter((t=>"monster"===t.type&&b.includes(t.target))),w=[];w.push(...(0,i.resolveDaggerIntent)(Object.assign(Object.assign({},j),{paths:[...S.blocks.filter((t=>t.target===c.Block.dagger)),...I.blocks.filter((t=>t.target===c.Block.dagger))]}))),O?w.push(...(0,l.resolveSafetyIntent)(Object.assign(Object.assign({},j),{paths:A}))):w.push(...(0,a.resolveCoinIntent)(Object.assign(Object.assign({},j),{paths:D.blocks.filter((t=>t.target===c.Block.coin))})),...(0,r.resolveKillIntent)(Object.assign(Object.assign({},j),{paths:A})),...(0,n.resolveBonusIntent)(Object.assign(Object.assign({},j),{paths:D.blocks.filter((t=>t.target===c.Block.bonus))})));const B=O?w:w.filter((e=>{if(!e.target)return!0;let s=-1,o=m[y.position.y][y.position.x];return(0,u.simulatePath)({actions:e.actions,start:y.position,end:e.target,type:"path"},((e,n)=>{if(null!=y.dagger&&y.dagger.ticksLeft>4)return!1;if((0,l.isDeath)({player:y,position:n,blocks:t.map.blocks,monsterRealms:x,safetyMatrix:m}))return!0;const a=(0,c.isInMonsterRealm)({position:n,blocks:t.map.blocks,realms:x});for(const i of a){const a=(0,c.calculateSafetyMatrix)({blocks:t.map.blocks,dangers:[t.monsters[i].position]})[n.y][n.x],r=a>=o?1:2;if(o=a,a<(e+1)*r)return s=e,!0}})),-1===s||s>1}));return 0===B.length?[{actions:[o.Action.stay],target:y.position,certainty:0,duration:0,payoff:0,validateSafety:!1}]:B.sort(((t,e)=>{const s=t.certainty*t.payoff,o=e.certainty*e.payoff,n=s/t.duration;return o/e.duration-n}))},e.tick=t=>{const s=(0,e.getSortedIntents)(t);return console.error(JSON.stringify(s.slice(0,3),null,2)),s[0]}},974:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.manhattanDistance=void 0,e.manhattanDistance=(t,e)=>Math.abs(t.x-e.x)+Math.abs(t.y-e.y)},561:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Vector2=void 0;class s{constructor(t,e){this.x=t,this.y=e}add(t){return new s(this.x+t.x,this.y+t.y)}addMany(...t){return t.reduce(((t,e)=>t.add(e)),this)}sub(t){return new s(this.x-t.x,this.y-t.y)}equals(t){return this.x===t.x&&this.y===t.y}copy(){return new s(this.x,this.y)}toString(){return`(${this.x}, ${this.y})`}}e.Vector2=s},165:(t,e,s)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isVisible=e.calculateVisibilityMatrix=void 0;const o=s(601),n=s(656),a=s(974),i=(t,e,s,o,n)=>{const a=s-t;let i=o-e,r=1;i<0&&(r=-1,i=-i);let l=2*i-a,c=e;for(let e=t;e<=s&&!n(e,c);e++)l>0?(c+=r,l+=2*(i-a)):l+=2*i},r=(t,e,s,o,n)=>{let a=s-t;const i=o-e;let r=1;a<0&&(r=-1,a=-a);let l=2*a-i,c=t;for(let t=e;t<=o&&!n(c,t);t++)l>0?(c+=r,l+=2*(a-i)):l+=2*a};e.calculateVisibilityMatrix=({positions:t,blocks:e,radius:s})=>{const l=[],c=null!=s?s:o.Constants.defaultVisibilityRadius;for(let t=0;t<e.length;t++){l.push([]);for(let s=0;s<e[t].length;s++)l[t].push(!1)}for(const s of t)for(let t=0;t<e.length;t++)for(let o=0;o<e[t].length;o++){let g=!1;u=s.x,f=s.y,p=o,d=t,y=(t,o)=>{const i=new n.Vector2(t,o);return((0,a.manhattanDistance)(i,s)>=c||e[o][t]===n.Block.wall)&&(g=!0,!0)},Math.abs(d-f)<Math.abs(p-u)?u<p?i(u,f,p,d,y):i(p,d,u,f,y):f<d?r(u,f,p,d,y):r(p,d,u,f,y),l[t][o]=l[t][o]||!g}var u,f,p,d,y;return l},e.isVisible=({light:t,position:s,blocks:o})=>(0,e.calculateVisibilityMatrix)({positions:[t],blocks:o})[s.y][s.x]},147:t=>{"use strict";t.exports=require("fs")}},e={};function s(o){var n=e[o];if(void 0!==n)return n.exports;var a=e[o]={exports:{}};return t[o].call(a.exports,a,a.exports,s),a.exports}(()=>{"use strict";const t=s(532),e=s(410),o=[],n=[];for(;;)try{const s=(0,t.getState)({history:o}),a=(0,e.tick)({state:s,stateHistory:o,intentHistory:n});console.log(a.actions[0]),console.error(a.actions[0]),o.push(s),n.push(a)}catch(t){console.error(t)}})()})();